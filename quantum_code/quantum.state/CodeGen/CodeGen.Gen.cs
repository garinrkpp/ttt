#pragma warning disable 0649
#pragma warning disable 1522
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Quantum {
  using System;
  using Photon.Deterministic;
  using Quantum.Core;
  
  public enum DamageType {
    Magical,
    Physical,
  }
  public enum EntityTypes {
    Projectile,
    Character,
  }
  public enum ComponentTypes : long {
    DynamicBody = 1 << 0,
    Transform2D = 1 << 1,
    Animator = 1 << 2,
    NavMeshAgent = 1 << 2,
    Prefab = 1 << 3,
    Transform2DVertical = 1 << 4,
    Resources = 1 << 5,
  }
  public static class ComponentTypes_ext {
    public static Boolean HasFlag(this ComponentTypes self, ComponentTypes flag) {
      return (self & flag) == flag;
    }
    public static ComponentTypes SetFlag(this ComponentTypes self, ComponentTypes flag) {
      return self | flag;
    }
    public static ComponentTypes ClearFlag(this ComponentTypes self, ComponentTypes flag) {
      return self & ~flag;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct BitSet128 {
    public fixed uint bits[4];
    public const Int32 BitsSize = 128;
    public static void Set(BitSet128* set, Int32 bit) {
      set->bits[bit/32] |= (1u<<(bit%32));
    }
    public static void Clear(BitSet128* set, Int32 bit) {
      set->bits[bit/32] &= ~(1u<<(bit%32));
    }
    public static void ClearAll(BitSet128* set) {
      *set = _default_.BitSet128;
    }
    public static Boolean IsSet(BitSet128* set, Int32 bit) {
      return (set->bits[bit/32]&(1u<<(bit%32))) != 0u;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct BitSet256 {
    public fixed uint bits[8];
    public const Int32 BitsSize = 256;
    public static void Set(BitSet256* set, Int32 bit) {
      set->bits[bit/32] |= (1u<<(bit%32));
    }
    public static void Clear(BitSet256* set, Int32 bit) {
      set->bits[bit/32] &= ~(1u<<(bit%32));
    }
    public static void ClearAll(BitSet256* set) {
      *set = _default_.BitSet256;
    }
    public static Boolean IsSet(BitSet256* set, Int32 bit) {
      return (set->bits[bit/32]&(1u<<(bit%32))) != 0u;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct BitSet512 {
    public fixed uint bits[16];
    public const Int32 BitsSize = 512;
    public static void Set(BitSet512* set, Int32 bit) {
      set->bits[bit/32] |= (1u<<(bit%32));
    }
    public static void Clear(BitSet512* set, Int32 bit) {
      set->bits[bit/32] &= ~(1u<<(bit%32));
    }
    public static void ClearAll(BitSet512* set) {
      *set = _default_.BitSet512;
    }
    public static Boolean IsSet(BitSet512* set, Int32 bit) {
      return (set->bits[bit/32]&(1u<<(bit%32))) != 0u;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct BitSet1024 {
    public fixed uint bits[32];
    public const Int32 BitsSize = 1024;
    public static void Set(BitSet1024* set, Int32 bit) {
      set->bits[bit/32] |= (1u<<(bit%32));
    }
    public static void Clear(BitSet1024* set, Int32 bit) {
      set->bits[bit/32] &= ~(1u<<(bit%32));
    }
    public static void ClearAll(BitSet1024* set) {
      *set = _default_.BitSet1024;
    }
    public static Boolean IsSet(BitSet1024* set, Int32 bit) {
      return (set->bits[bit/32]&(1u<<(bit%32))) != 0u;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct BitSet2048 {
    public fixed uint bits[64];
    public const Int32 BitsSize = 2048;
    public static void Set(BitSet2048* set, Int32 bit) {
      set->bits[bit/32] |= (1u<<(bit%32));
    }
    public static void Clear(BitSet2048* set, Int32 bit) {
      set->bits[bit/32] &= ~(1u<<(bit%32));
    }
    public static void ClearAll(BitSet2048* set) {
      *set = _default_.BitSet2048;
    }
    public static Boolean IsSet(BitSet2048* set, Int32 bit) {
      return (set->bits[bit/32]&(1u<<(bit%32))) != 0u;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct BitSet4096 {
    public fixed uint bits[128];
    public const Int32 BitsSize = 4096;
    public static void Set(BitSet4096* set, Int32 bit) {
      set->bits[bit/32] |= (1u<<(bit%32));
    }
    public static void Clear(BitSet4096* set, Int32 bit) {
      set->bits[bit/32] &= ~(1u<<(bit%32));
    }
    public static void ClearAll(BitSet4096* set) {
      *set = _default_.BitSet4096;
    }
    public static Boolean IsSet(BitSet4096* set, Int32 bit) {
      return (set->bits[bit/32]&(1u<<(bit%32))) != 0u;
    }
  }
  public unsafe partial struct _default_ {
    public static CharacterSpec CharacterSpec;
    public static Resources Resources;
    public static Projectile Projectile;
    public static Character Character;
    public static DamageType DamageType;
    public static DamageData DamageData;
    public static EntityTypes EntityTypes;
    public static BitSet128 BitSet128;
    public static BitSet256 BitSet256;
    public static BitSet512 BitSet512;
    public static BitSet1024 BitSet1024;
    public static BitSet2048 BitSet2048;
    public static BitSet4096 BitSet4096;
    internal AssetRefCharacterSpec AssetRefCharacterSpec;
    public static EntityRefProjectile EntityRefProjectile;
    public static EntityRefCharacter EntityRefCharacter;
    public static ComponentTypes ComponentTypes;
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct AssetRefCharacterSpec {
    private Int32 _id;
    public CharacterSpec Asset {
      get {
        return DB.FindAsset<CharacterSpec>(this._id);
      }
      set {
        if (value == null) {
          _id = 0;
        } else {
          _id = value.Id;
        }
      }
    }
    public Int32 Id {
      get {
        return _id;
      }
    }
    public static implicit operator AssetRefCharacterSpec(CharacterSpec value) {
      var r = default(AssetRefCharacterSpec);
      if (value != null) {
        r._id = value.Id;
      }
      return r;
    }
    public static implicit operator CharacterSpec(AssetRefCharacterSpec value) {
      return DB.FindAsset<CharacterSpec>(value._id);
    }
    public override Int32 GetHashCode() {
      return _id;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct EntityRefProjectile : System.IEquatable<EntityRefProjectile> {
    internal Int32 _index;
    internal Int32 _version;
    public static readonly EntityRefProjectile None = default(EntityRefProjectile);
    public static implicit operator EntityRefProjectile(EntityRef value) {
      if (value._type != EntityTypes.Projectile) {
        throw new System.Exception("entity_ref can't be converted to EntityRefProjectile, it has type " + value._type);
      }
      EntityRefProjectile r;
      r._index = value._index;
      r._version = value._version;
      return r;
    }
    public static implicit operator EntityRef(EntityRefProjectile value) {
      EntityRef r;
      r._index = value._index;
      r._version = value._version;
      r._type = EntityTypes.Projectile;
      return r;
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 37;
        hash = hash * 31 + _index;
        hash = hash * 31 + _version;
        return hash;
      }
    }
    public override Boolean Equals(object other) {
      if (other is EntityRefProjectile) {
        this.Equals((EntityRefProjectile)other);
      }
      return false;
    }
    public Boolean Equals(EntityRefProjectile other) {
      return this._index == other._index && this._version == other._version;
    }
    public static Boolean operator ==(EntityRefProjectile a, EntityRefProjectile b) {
      return a._index == b._index && a._version == b._version;
    }
    public static Boolean operator !=(EntityRefProjectile a, EntityRefProjectile b) {
      return a._index != b._index || a._version != b._version;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct EntityRefCharacter : System.IEquatable<EntityRefCharacter> {
    internal Int32 _index;
    internal Int32 _version;
    public static readonly EntityRefCharacter None = default(EntityRefCharacter);
    public static implicit operator EntityRefCharacter(EntityRef value) {
      if (value._type != EntityTypes.Character) {
        throw new System.Exception("entity_ref can't be converted to EntityRefCharacter, it has type " + value._type);
      }
      EntityRefCharacter r;
      r._index = value._index;
      r._version = value._version;
      return r;
    }
    public static implicit operator EntityRef(EntityRefCharacter value) {
      EntityRef r;
      r._index = value._index;
      r._version = value._version;
      r._type = EntityTypes.Character;
      return r;
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 41;
        hash = hash * 31 + _index;
        hash = hash * 31 + _version;
        return hash;
      }
    }
    public override Boolean Equals(object other) {
      if (other is EntityRefCharacter) {
        this.Equals((EntityRefCharacter)other);
      }
      return false;
    }
    public Boolean Equals(EntityRefCharacter other) {
      return this._index == other._index && this._version == other._version;
    }
    public static Boolean operator ==(EntityRefCharacter a, EntityRefCharacter b) {
      return a._index == b._index && a._version == b._version;
    }
    public static Boolean operator !=(EntityRefCharacter a, EntityRefCharacter b) {
      return a._index != b._index || a._version != b._version;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct AnimatorFilter {
    public Entity* Entity;
    public Animator* Animator;
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct PrefabFilter {
    public Entity* Entity;
    public Prefab* Prefab;
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct Transform2DFilter {
    public Entity* Entity;
    public Transform2D* Transform2D;
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct Transform2DVerticalFilter {
    public Entity* Entity;
    public Transform2DVertical* Transform2DVertical;
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct NavMeshAgentFilter {
    public Entity* Entity;
    public NavMeshAgent* NavMeshAgent;
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct DynamicBodyFilter {
    public Entity* Entity;
    public DynamicBody* DynamicBody;
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct Resources {
    public FP Health;
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct ResourcesFilter {
    public Entity* Entity;
    public Resources* Resources;
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct Projectile {
    internal Entity _entity;
    public Transform2D Transform2D;
    public DynamicBody DynamicBody;
    public const Int32 MAX_COUNT = 64;
    public EntityRefCharacter Source;
    public FP Time;
    public EntityRef EntityRef {
      get {
        return _entity._ref;
      }
    }
    public Int32 EntityIndex {
      get {
        return _entity._ref._index;
      }
    }
    public Boolean IsActive {
      get {
        return _entity._active;
      }
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct ProjectileIterator {
    private Int32 _index;
    private Projectile* _ptr;
    public Projectile* Current;
    public ProjectileIterator(Projectile* ptr) {
      _ptr = ptr;
      _index = -1;
      Current = null;
    }
    public Boolean Next() {
      while (++_index < Projectile.MAX_COUNT) {
        if (_ptr[_index]._entity._active) {
          Current = &_ptr[_index];
          return true;
        }
      }
      Current = null;
      return false;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct Character {
    internal Entity _entity;
    public Transform2D Transform2D;
    public DynamicBody DynamicBody;
    public Resources Resources;
    public Prefab Prefab;
    public const Int32 MAX_COUNT = 8;
    public PlayerRef Player;
    private AssetRefCharacterSpec _CharacterSpec;
    public EntityRef EntityRef {
      get {
        return _entity._ref;
      }
    }
    public Int32 EntityIndex {
      get {
        return _entity._ref._index;
      }
    }
    public Boolean IsActive {
      get {
        return _entity._active;
      }
    }
    public CharacterSpec CharacterSpec {
      get {
        return _CharacterSpec.Asset;
      }
      set {
        _CharacterSpec.Asset = value;
      }
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct CharacterIterator {
    private Int32 _index;
    private Character* _ptr;
    public Character* Current;
    public CharacterIterator(Character* ptr) {
      _ptr = ptr;
      _index = -1;
      Current = null;
    }
    public Boolean Next() {
      while (++_index < Character.MAX_COUNT) {
        if (_ptr[_index]._entity._active) {
          Current = &_ptr[_index];
          return true;
        }
      }
      Current = null;
      return false;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct DamageData {
    public EntityRefCharacter Character;
    public FP Damage;
    public DamageType Type;
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 43;
        hash = hash * 31 + Character.GetHashCode();
        hash = hash * 31 + Damage.GetHashCode();
        hash = hash * 31 + Type.GetHashCode();
        return hash;
      }
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct _entities_ {
    private Projectile Projectile0;
    private Projectile Projectile1;
    private Projectile Projectile2;
    private Projectile Projectile3;
    private Projectile Projectile4;
    private Projectile Projectile5;
    private Projectile Projectile6;
    private Projectile Projectile7;
    private Projectile Projectile8;
    private Projectile Projectile9;
    private Projectile Projectile10;
    private Projectile Projectile11;
    private Projectile Projectile12;
    private Projectile Projectile13;
    private Projectile Projectile14;
    private Projectile Projectile15;
    private Projectile Projectile16;
    private Projectile Projectile17;
    private Projectile Projectile18;
    private Projectile Projectile19;
    private Projectile Projectile20;
    private Projectile Projectile21;
    private Projectile Projectile22;
    private Projectile Projectile23;
    private Projectile Projectile24;
    private Projectile Projectile25;
    private Projectile Projectile26;
    private Projectile Projectile27;
    private Projectile Projectile28;
    private Projectile Projectile29;
    private Projectile Projectile30;
    private Projectile Projectile31;
    private Projectile Projectile32;
    private Projectile Projectile33;
    private Projectile Projectile34;
    private Projectile Projectile35;
    private Projectile Projectile36;
    private Projectile Projectile37;
    private Projectile Projectile38;
    private Projectile Projectile39;
    private Projectile Projectile40;
    private Projectile Projectile41;
    private Projectile Projectile42;
    private Projectile Projectile43;
    private Projectile Projectile44;
    private Projectile Projectile45;
    private Projectile Projectile46;
    private Projectile Projectile47;
    private Projectile Projectile48;
    private Projectile Projectile49;
    private Projectile Projectile50;
    private Projectile Projectile51;
    private Projectile Projectile52;
    private Projectile Projectile53;
    private Projectile Projectile54;
    private Projectile Projectile55;
    private Projectile Projectile56;
    private Projectile Projectile57;
    private Projectile Projectile58;
    private Projectile Projectile59;
    private Projectile Projectile60;
    private Projectile Projectile61;
    private Projectile Projectile62;
    private Projectile Projectile63;
    private Character Character0;
    private Character Character1;
    private Character Character2;
    private Character Character3;
    private Character Character4;
    private Character Character5;
    private Character Character6;
    private Character Character7;
    public Int32 ProjectileSize {
      get {
        return 64;
      }
    }
    public Int32 CharacterSize {
      get {
        return 8;
      }
    }
    [Quantum.Core.PatchArrayAccessorAttribute("Projectile0", "index", 64)]
    public Projectile* Projectile(Int32 index) {
      return null;
    }
    [Quantum.Core.PatchArrayAccessorAttribute("Character0", "index", 8)]
    public Character* Character(Int32 index) {
      return null;
    }
  }
  public enum InputButtons {
    Fire = 1 << 0,
  }
  public static class InputButtons_ext {
    public static Boolean HasFlag(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct Input {
    public FPVector2 Movement;
    public Button Fire;
    public static Input Read(ByteStream stream) {
      return Serialize(stream, new Input(), false);
    }
    public static void Write(ByteStream stream, Input i) {
      Serialize(stream, i, true);
    }
    private static Input Serialize(ByteStream s, Input i, Boolean w) {
      i.Movement = s.Serialize(w, i.Movement);
      i.Fire = s.Serialize(w, i.Fire);
      return i;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.Fire: return Fire.IsDown;
      }
      return false;
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.Fire: return Fire.WasPressed;
      }
      return false;
    }
  }
  [System.Runtime.InteropServices.StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind.Sequential, Pack=Quantum.Core.CodeGenConstants.STRUCT_PACK)]
  public unsafe partial struct _globals_ {
    private Input input0;
    private Input input1;
    private Input input2;
    private Input input3;
    private Input input4;
    private Input input5;
    public DynamicSceneSettings PhysicsSettings;
    public RNGSession RngSession;
    public AssetRefMap Map;
    public BitSet256 Systems;
    public FP DeltaTime;
    public Int32 inputSize {
      get {
        return 6;
      }
    }
    [Quantum.Core.PatchArrayAccessorAttribute("input0", "index", 6)]
    public Input* input(Int32 index) {
      return null;
    }
  }
  public unsafe partial class Frame {
    private ISignalOnDamage[] _ISignalOnDamageSystems;
    private ISignalOnDamageBefore[] _ISignalOnDamageBeforeSystems;
    private ISignalOnProjectileCreated[] _ISignalOnProjectileCreatedSystems;
    private ISignalOnProjectileDestroy[] _ISignalOnProjectileDestroySystems;
    private ISignalOnCharacterCreated[] _ISignalOnCharacterCreatedSystems;
    private ISignalOnCharacterDestroy[] _ISignalOnCharacterDestroySystems;
    partial void AllocGen() {
      _globals = (_globals_*)Native.Alloc(sizeof(_globals_)).ToPointer();
      Native.Zero((Byte*)_globals, sizeof(_globals_));
      _entities = (_entities_*)Native.Alloc(sizeof(_entities_)).ToPointer();
      Native.Zero((Byte*)_entities, sizeof(_entities_));
    }
    partial void FreeGen() {
      Native.Free(new IntPtr(_globals));
      Native.Free(new IntPtr(_entities));
    }
    partial void CopyFromGen(Frame frame) {
      Native.Copy(_globals, frame._globals, (ulong)sizeof(_globals_));
      Native.Copy(_entities, frame._entities, (ulong)sizeof(_entities_));
    }
    partial void InitGen() {
      {
        var ptr = _entities->Projectile(0);
        for (var i = 0; i < 64; ++i, ++ptr) {
          ptr->_entity._ref._index = i;
          ptr->_entity._ref._version = 1;
          ptr->_entity._ref._type = EntityTypes.Projectile;
        }
      }
      {
        var ptr = _entities->Character(0);
        for (var i = 0; i < 8; ++i, ++ptr) {
          ptr->_entity._ref._index = i;
          ptr->_entity._ref._version = 1;
          ptr->_entity._ref._type = EntityTypes.Character;
        }
      }
      _ISignalOnDamageSystems = BuildSignalsArray<ISignalOnDamage>();
      _ISignalOnDamageBeforeSystems = BuildSignalsArray<ISignalOnDamageBefore>();
      _ISignalOnProjectileCreatedSystems = BuildSignalsArray<ISignalOnProjectileCreated>();
      _ISignalOnProjectileDestroySystems = BuildSignalsArray<ISignalOnProjectileDestroy>();
      _ISignalOnCharacterCreatedSystems = BuildSignalsArray<ISignalOnCharacterCreated>();
      _ISignalOnCharacterDestroySystems = BuildSignalsArray<ISignalOnCharacterDestroy>();
    }
    public Buffer<EntityFilter> GetAllEntities() {
      var all = Buffer<EntityFilter>.Alloc(72);
      {
        var ptr = _entities->Projectile(0);
        for (var i = 0; i < 64; ++i, ++ptr) {
          if (ptr->_entity._active) {
            all.Items[all.Count++].Entity = &ptr->_entity;
          }
        }
      }
      {
        var ptr = _entities->Character(0);
        for (var i = 0; i < 8; ++i, ++ptr) {
          if (ptr->_entity._active) {
            all.Items[all.Count++].Entity = &ptr->_entity;
          }
        }
      }
      return all;
    }
    private EntityFilter[] GetAllEntitiesUnsafe() {
      var all = new EntityFilter[72];
      var count = 0;
      {
        var ptr = _entities->Projectile(0);
        for (var i = 0; i < 64; ++i, ++ptr) {
          all[count++].Entity = &ptr->_entity;
        }
      }
      {
        var ptr = _entities->Character(0);
        for (var i = 0; i < 8; ++i, ++ptr) {
          all[count++].Entity = &ptr->_entity;
        }
      }
      return all;
    }
    public Entity* GetEntity(EntityRef entity_ref) {
      switch (entity_ref._type) {
        case EntityTypes.Projectile: return (Entity*)GetProjectile(entity_ref);
        case EntityTypes.Character: return (Entity*)GetCharacter(entity_ref);
      }
      return null;
    }
    public void DestroyEntity(Entity* entity) {
      if (entity == null) {
        Log.Error("can't destroy null pointer");
        return;
      }
      if (entity->_active == false) {
        Log.Error("entity already destroyed");
        return;
      }
      _destroy.Enqueue(entity->EntityRef);
    }
    private void DestroyEntityInternal(Entity* entity) {
      if (entity == null) {
        return;
      }
      if (entity->_active == false) {
        return;
      }
      switch (entity->_ref._type) {
        case EntityTypes.Projectile: DestroyProjectileInternal((Projectile*)entity); break;
        case EntityTypes.Character: DestroyCharacterInternal((Character*)entity); break;
      }
    }
    public void DestroyEntity(EntityRef entity_ref) {
      _destroy.Enqueue(entity_ref);
    }
    public Boolean ProjectileExists(EntityRefProjectile entity_ref) {
      return GetProjectile(entity_ref) != null;
    }
    public Projectile* CreateProjectile() {
      var ptr = _entities->Projectile(0);
      for (var i = 0; i < 64; ++i, ++ptr) {
        if (ptr->_entity._active == false) {
          EntityCreate(&ptr->_entity);
          Signals.OnEntityCreated(&ptr->_entity);
          Signals.OnProjectileCreated(ptr);
          return ptr;
        }
      }
      return null;
    }
    private void DestroyProjectileInternal(Projectile* ptr) {
      Signals.OnProjectileDestroy(ptr);
      Signals.OnEntityDestroy(&ptr->_entity);
      var copy = ptr->_entity;
      *ptr = _default_.Projectile;
      ptr->_entity = copy;
      EntityDestroy(&ptr->_entity);
    }
    public void DestroyProjectile(Projectile* ptr) {
      if (ptr == null) {
        return;
      }
      if (ptr->_entity._active == false) {
        return;
      }
      _destroy.Enqueue(ptr->EntityRef);
    }
    public void DestroyProjectile(EntityRefProjectile entity_ref) {
      _destroy.Enqueue(entity_ref);
    }
    public Projectile* GetProjectile(EntityRefProjectile entity_ref) {
      var ptr = _entities->Projectile(entity_ref._index);
      if (ptr->_entity._active && ptr->_entity._ref._version == entity_ref._version) {
        return ptr;
      }
      return null;
    }
    public ProjectileIterator GetAllProjectiles() {
      return new ProjectileIterator(_entities->Projectile(0));
    }
    public Boolean CharacterExists(EntityRefCharacter entity_ref) {
      return GetCharacter(entity_ref) != null;
    }
    public Character* CreateCharacter() {
      var ptr = _entities->Character(0);
      for (var i = 0; i < 8; ++i, ++ptr) {
        if (ptr->_entity._active == false) {
          EntityCreate(&ptr->_entity);
          Signals.OnEntityCreated(&ptr->_entity);
          Signals.OnCharacterCreated(ptr);
          return ptr;
        }
      }
      return null;
    }
    private void DestroyCharacterInternal(Character* ptr) {
      Signals.OnCharacterDestroy(ptr);
      Signals.OnEntityDestroy(&ptr->_entity);
      var copy = ptr->_entity;
      *ptr = _default_.Character;
      ptr->_entity = copy;
      EntityDestroy(&ptr->_entity);
    }
    public void DestroyCharacter(Character* ptr) {
      if (ptr == null) {
        return;
      }
      if (ptr->_entity._active == false) {
        return;
      }
      _destroy.Enqueue(ptr->EntityRef);
    }
    public void DestroyCharacter(EntityRefCharacter entity_ref) {
      _destroy.Enqueue(entity_ref);
    }
    public Character* GetCharacter(EntityRefCharacter entity_ref) {
      var ptr = _entities->Character(entity_ref._index);
      if (ptr->_entity._active && ptr->_entity._ref._version == entity_ref._version) {
        return ptr;
      }
      return null;
    }
    public CharacterIterator GetAllCharacters() {
      return new CharacterIterator(_entities->Character(0));
    }
    public Buffer<AnimatorFilter> GetAllAnimators() {
      var b = Buffer<AnimatorFilter>.Alloc(72);
      return b;
    }
    public Buffer<DynamicBodyFilter> GetAllDynamicBodies() {
      var b = Buffer<DynamicBodyFilter>.Alloc(72);
      {
        var ptr = _entities->Projectile(0);
        for (var i = 64 - 1; i >= 0; --i, ++ptr) {
          if (ptr->_entity._active) {
            b.Items[b.Count].Entity = &ptr->_entity;
            b.Items[b.Count].DynamicBody = &ptr->DynamicBody;
            ++b.Count;
          }
        }
      }
      {
        var ptr = _entities->Character(0);
        for (var i = 8 - 1; i >= 0; --i, ++ptr) {
          if (ptr->_entity._active) {
            b.Items[b.Count].Entity = &ptr->_entity;
            b.Items[b.Count].DynamicBody = &ptr->DynamicBody;
            ++b.Count;
          }
        }
      }
      return b;
    }
    public Buffer<NavMeshAgentFilter> GetAllNavMeshAgents() {
      var b = Buffer<NavMeshAgentFilter>.Alloc(72);
      return b;
    }
    public Buffer<PrefabFilter> GetAllPrefabs() {
      var b = Buffer<PrefabFilter>.Alloc(72);
      {
        var ptr = _entities->Character(0);
        for (var i = 8 - 1; i >= 0; --i, ++ptr) {
          if (ptr->_entity._active) {
            b.Items[b.Count].Entity = &ptr->_entity;
            b.Items[b.Count].Prefab = &ptr->Prefab;
            ++b.Count;
          }
        }
      }
      return b;
    }
    public Buffer<ResourcesFilter> GetAllResources() {
      var b = Buffer<ResourcesFilter>.Alloc(72);
      {
        var ptr = _entities->Character(0);
        for (var i = 8 - 1; i >= 0; --i, ++ptr) {
          if (ptr->_entity._active) {
            b.Items[b.Count].Entity = &ptr->_entity;
            b.Items[b.Count].Resources = &ptr->Resources;
            ++b.Count;
          }
        }
      }
      return b;
    }
    public Buffer<Transform2DFilter> GetAllTransform2Ds() {
      var b = Buffer<Transform2DFilter>.Alloc(72);
      {
        var ptr = _entities->Projectile(0);
        for (var i = 64 - 1; i >= 0; --i, ++ptr) {
          if (ptr->_entity._active) {
            b.Items[b.Count].Entity = &ptr->_entity;
            b.Items[b.Count].Transform2D = &ptr->Transform2D;
            ++b.Count;
          }
        }
      }
      {
        var ptr = _entities->Character(0);
        for (var i = 8 - 1; i >= 0; --i, ++ptr) {
          if (ptr->_entity._active) {
            b.Items[b.Count].Entity = &ptr->_entity;
            b.Items[b.Count].Transform2D = &ptr->Transform2D;
            ++b.Count;
          }
        }
      }
      return b;
    }
    public Buffer<Transform2DVerticalFilter> GetAllTransform2DVerticals() {
      var b = Buffer<Transform2DVerticalFilter>.Alloc(72);
      return b;
    }
    public void SetPlayerInput(Int32 player, Input input) {
      if (player < 0 || player >= _globals->inputSize) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input(player);
      i->Movement = input.Movement;
      i->Fire = i->Fire.Update(this.Number, input.Fire);
    }
    public Input* GetPlayerInput(Int32 player) {
      if (player < 0 || player >= _globals->inputSize) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input(player);
    }
    public unsafe partial class FrameSignals {
      public void OnDamage(DamageData dmg) {
        var array = _f._ISignalOnDamageSystems;
        var systems = &(_f._globals->Systems);
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (BitSet256.IsSet(systems, s.RuntimeIndex)) {
            s.OnDamage(_f, dmg);
          }
        }
      }
      public void OnDamageBefore(DamageData* dmg) {
        var array = _f._ISignalOnDamageBeforeSystems;
        var systems = &(_f._globals->Systems);
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (BitSet256.IsSet(systems, s.RuntimeIndex)) {
            s.OnDamageBefore(_f, dmg);
          }
        }
      }
      public void OnProjectileCreated(Projectile* entity) {
        var array = _f._ISignalOnProjectileCreatedSystems;
        var systems = &(_f._globals->Systems);
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (BitSet256.IsSet(systems, s.RuntimeIndex)) {
            s.OnProjectileCreated(_f, entity);
          }
        }
      }
      public void OnProjectileDestroy(Projectile* entity) {
        var array = _f._ISignalOnProjectileDestroySystems;
        var systems = &(_f._globals->Systems);
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (BitSet256.IsSet(systems, s.RuntimeIndex)) {
            s.OnProjectileDestroy(_f, entity);
          }
        }
      }
      public void OnCharacterCreated(Character* entity) {
        var array = _f._ISignalOnCharacterCreatedSystems;
        var systems = &(_f._globals->Systems);
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (BitSet256.IsSet(systems, s.RuntimeIndex)) {
            s.OnCharacterCreated(_f, entity);
          }
        }
      }
      public void OnCharacterDestroy(Character* entity) {
        var array = _f._ISignalOnCharacterDestroySystems;
        var systems = &(_f._globals->Systems);
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (BitSet256.IsSet(systems, s.RuntimeIndex)) {
            s.OnCharacterDestroy(_f, entity);
          }
        }
      }
    }
    public unsafe partial class FrameEvents {
      public const Int32 EVENT_TYPE_COUNT = 2;
      public void CharacterDamage(EntityRefCharacter Character, FP Damage) {
      var ev = EventPool<EventCharacterDamage>.Alloc();
      ev._Character = Character;
      ev._Damage = Damage;
      _f.AddEvent(ev);
      }
    }
  }
  public unsafe partial struct Entity {
    public static Animator* GetAnimator(Entity* entity) {
      switch (entity->_ref._type) {
      }
      return null;
    }
    public static DynamicBody* GetDynamicBody(Entity* entity) {
      switch (entity->_ref._type) {
        case EntityTypes.Projectile:
          return &((Projectile*)entity)->DynamicBody;
        case EntityTypes.Character:
          return &((Character*)entity)->DynamicBody;
      }
      return null;
    }
    public static NavMeshAgent* GetNavMeshAgent(Entity* entity) {
      switch (entity->_ref._type) {
      }
      return null;
    }
    public static Prefab* GetPrefab(Entity* entity) {
      switch (entity->_ref._type) {
        case EntityTypes.Character:
          return &((Character*)entity)->Prefab;
      }
      return null;
    }
    public static Resources* GetResources(Entity* entity) {
      switch (entity->_ref._type) {
        case EntityTypes.Character:
          return &((Character*)entity)->Resources;
      }
      return null;
    }
    public static Transform2D* GetTransform2D(Entity* entity) {
      switch (entity->_ref._type) {
        case EntityTypes.Projectile:
          return &((Projectile*)entity)->Transform2D;
        case EntityTypes.Character:
          return &((Character*)entity)->Transform2D;
      }
      return null;
    }
    public static Transform2DVertical* GetTransform2DVertical(Entity* entity) {
      switch (entity->_ref._type) {
      }
      return null;
    }
    public static Projectile* CastToProjectile(Entity* entity) {
      if (entity != null && entity->_ref.Type == EntityTypes.Projectile) {
        return (Projectile*)entity;
      }
      return null;
    }
    public static Character* CastToCharacter(Entity* entity) {
      if (entity != null && entity->_ref.Type == EntityTypes.Character) {
        return (Character*)entity;
      }
      return null;
    }
  }
  public unsafe interface ISignalOnDamage {
    Int32 RuntimeIndex {
      get;
    }
    void OnDamage(Frame f, DamageData dmg);
  }
  public unsafe interface ISignalOnDamageBefore {
    Int32 RuntimeIndex {
      get;
    }
    void OnDamageBefore(Frame f, DamageData* dmg);
  }
  public unsafe interface ISignalOnProjectileCreated {
    Int32 RuntimeIndex {
      get;
    }
    void OnProjectileCreated(Frame f, Projectile* entity);
  }
  public unsafe interface ISignalOnProjectileDestroy {
    Int32 RuntimeIndex {
      get;
    }
    void OnProjectileDestroy(Frame f, Projectile* entity);
  }
  public unsafe interface ISignalOnCharacterCreated {
    Int32 RuntimeIndex {
      get;
    }
    void OnCharacterCreated(Frame f, Character* entity);
  }
  public unsafe interface ISignalOnCharacterDestroy {
    Int32 RuntimeIndex {
      get;
    }
    void OnCharacterDestroy(Frame f, Character* entity);
  }
  public unsafe abstract partial class EventCharacterEvent : EventBase {
    public static new Action<EventCharacterEvent> OnRaised;
    internal EntityRefCharacter _Character;
    protected override Boolean Synced {
      get {
        return false;
      }
    }
    protected override Int32 Id {
      get {
        return 0;
      }
    }
    public EntityRefCharacter Character {
      get {
        return _Character;
      }
    }
    protected override void Raise() {
      base.Raise();
      if (OnRaised != null) { OnRaised(this); }
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 37;
        hash = hash * 31 + _Character.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class EventCharacterDamage : EventCharacterEvent {
    public static new Action<EventCharacterDamage> OnRaised;
    internal FP _Damage;
    protected override Boolean Synced {
      get {
        return false;
      }
    }
    protected override Int32 Id {
      get {
        return 1;
      }
    }
    public FP Damage {
      get {
        return _Damage;
      }
    }
    protected override void Raise() {
      base.Raise();
      if (OnRaised != null) { OnRaised(this); }
    }
    internal override void Release() {
      EventPool<EventCharacterDamage>.Free(this);
    }
    public override Int32 GetHashCode() {
      unchecked {
        var hash = 41;
        hash = hash * 31 + _Character.GetHashCode();
        hash = hash * 31 + _Damage.GetHashCode();
        return hash;
      }
    }
  }
  public unsafe partial class PhysicsSystemBase {
    partial void OnCollisionInternal(StaticCollisionInfo info, Int32 typesHash) {
      switch (typesHash) {
      }
    }
    partial void OnCollisionInternal(DynamicCollisionInfo info, Int32 typesHash) {
      switch (typesHash) {
      }
    }
    partial void OnTriggerInternal(StaticCollisionInfo info, Int32 typesHash) {
      switch (typesHash) {
      }
    }
    partial void OnTriggerInternal(DynamicCollisionInfo info, Int32 typesHash) {
      switch (typesHash) {
      }
    }
  }
  [System.SerializableAttribute()]
  public unsafe partial class CharacterSpec : AssetObject {
  }
  [Quantum.AssetLinkAttribute(typeof(CharacterSpec))]
  [System.SerializableAttribute()]
  public unsafe partial struct CharacterSpecLink {
    public String Guid;
    public CharacterSpec Instance {
      get {
        return DB.FindAsset<CharacterSpec>(Guid);
      }
    }
    public static implicit operator CharacterSpec(CharacterSpecLink value) {
      return DB.FindAsset<CharacterSpec>(value.Guid);
    }
  }
}
#pragma warning restore 0649
#pragma warning restore 1522
