using Quantum;
using System.Linq;
using System.Collections.Generic;
using UnityEditor;
using UnityEngine;
using System;
using System.IO;
using System.Text;

namespace Quantum.Editor {
  public static class GenerateAssetScripts {
    const string AUTO_GEN_HEADER =
  @"/**
 * This code was auto-generated by a tool, every time
 * the tool executes this code will be reset.
 *
 * If you need to extend the classes generated to add 
 * fields or methods to them, please create partial 
 * declarations in another file.
 **/
";

    const string ASSET_CREATE_MENU = @"[CreateAssetMenu(menuName = ""Quantum/Assets/#ASSETCREATEPATH#"")]";

    const string ASSET_TEMPLATE = AUTO_GEN_HEADER +
  @"
using Quantum;
using UnityEngine;

#ASSETCREATEMENU#
public partial class #NAME#Asset : #BASE# {
  public #NAME# Settings;

  public override AssetObject AssetObject {
    get { return Settings; }
  }
}
";

    const string ASSET_TEMPLATE_ABSTRACT = AUTO_GEN_HEADER +
  @"
using Quantum;
using UnityEngine;

public abstract partial class #NAME#Asset : #BASE# {
  
}
";

    const string LINK_STRUCT_PROPERTY_DRAWER =
  @"
[CustomPropertyDrawer(typeof(#LINK_TYPE_NAME#))]
public class #LINK_TYPE_NAME#PropertyDrawer : PropertyDrawer {
  public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) {
    AssetLinkDrawer.DrawAssetObjectSelector(position, property, label, typeof(#ASSET_TYPE_NAME#));
  }
}

";

    [MenuItem("Quantum/Generate Asset Linking Scripts")]
    public static void Generate() {
      GenerateAssetScrits();
      GenerateAssetLinkDrawers();

      AssetDatabase.SaveAssets();
      AssetDatabase.Refresh();
    }

    static void GenerateAssetLinkDrawers() {
      StringBuilder sb = new StringBuilder();
      sb.AppendLine("using Quantum;");
      sb.AppendLine("using UnityEngine;");
      sb.AppendLine("using UnityEditor;");
      sb.AppendLine("namespace Quantum.Editor {");

      foreach (var t in TypeUtils.GetTypesWithAttribute<AssetLinkAttribute>("quantum.state")) {
        if (CheckForDontGenerateLinkingScripts(t.Item1.Type)) {
          continue;
        }

        String template;

        template = LINK_STRUCT_PROPERTY_DRAWER.Replace("#LINK_TYPE_NAME#", t.Item0.Name);
        template = template.Replace("#ASSET_TYPE_NAME#", t.Item1.Type.Name + "Asset");

        sb.Append(template);
      }

      sb.AppendLine("}");

      var outputPath = PathUtils.Combine(Application.dataPath, "Quantum", "Editor", "PropertyDrawers", "Generated", "AssetLinkDrawers.cs");

      File.WriteAllText(outputPath, sb.ToString());
    }

    static void GenerateAssetScrits() {
      var types = typeof(AssetObject).GetSubClasses("quantum.state");

      foreach (var t in types) {
        if (CheckForDontGenerateLinkingScripts(t)) {
          continue;
        }

        if (t.IsAbstract) {
          EmitAssetScriptTemplate(t, ASSET_TEMPLATE_ABSTRACT);
        }
        else {
          EmitAssetScriptTemplate(t, ASSET_TEMPLATE);
        }
      }
    }

    static Boolean CheckForDontGenerateLinkingScripts(Type t) {
      while (t != typeof(AssetObject)) {
        var attr = t.GetAttribute<Quantum.AssetObjectConfigAttribute>();
        if (attr != null && attr.GenerateLinkingScripts == false) {
          return true;
        }

        t = t.BaseType;
      }

      return false;
    }

    static Boolean CheckForDontGenerateAssetCreateMenu(Type t) {
      var attr = t.GetAttribute<Quantum.AssetObjectConfigAttribute>();
      if (attr != null && attr.GenerateAssetCreateMenu == false) {
        return true;
      }

      return false;
    }
    static IEnumerable<String> GenerateAssetCreateParts(Type t) {
      yield return t.Name;

      t = t.BaseType;

      while (t != typeof(AssetObject)) {
        if (t.IsAbstract) {
          yield return t.Name;
        }

        t = t.BaseType;
      }
    }

    static String GenerateAssetCreatePath(Type t) {
      return String.Join("/", GenerateAssetCreateParts(t).Reverse().ToArray());
    }

    static String GetBaseTypeName(Type t) {
      if (t.BaseType == typeof(AssetObject)) {
        return "AssetBase";
      }

      return t.BaseType.Name + "Asset";
    }

    static String GenerateAssetCreateMenu(Type t) {
      if (CheckForDontGenerateAssetCreateMenu(t)) {
        return "";
      }

      return ASSET_CREATE_MENU.Replace("#ASSETCREATEPATH#", GenerateAssetCreatePath(t));
    }

    static void EmitAssetScriptTemplate(Type t, String template) {
      var outputPath = PathUtils.Combine(Application.dataPath, "Quantum", "AssetTypes", "Generated", t.Name + "Asset.cs");

      // replace variables
      template = template.Replace("#NAME#", t.Name);
      template = template.Replace("#BASE#", GetBaseTypeName(t));
      template = template.Replace("#ASSETCREATEMENU#", GenerateAssetCreateMenu(t));

      // write text
      File.WriteAllText(outputPath, template);

    }
  }
}